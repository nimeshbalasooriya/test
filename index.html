<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Gesture Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; z-index: 10; }
        .hint { font-size: 0.8em; color: #888; margin-top: 5px; }
        video { position: absolute; bottom: 10px; right: 10px; width: 160px; height: 120px; border: 1px solid #444; transform: scaleX(-1); }
        #canvas-container { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="ui">
        <h2>Everything About Technical</h2>
        <div id="status">Loading AI Models...</div>
        <div class="hint">• <b>1 Finger:</b> Saturn | <b>2 Fingers:</b> Heart | <b>3 Fingers:</b> Flower | <b>4+ Fingers:</b> Fireworks</div>
        <div class="hint">• <b>Pinch (Thumb+Index):</b> Expand/Contract</div>
        <div class="hint">• <b>Move Hand:</b> Change Color & Rotation</div>
    </div>
    <video id="webcam" autoplay playsinline></video>

    <!-- Load Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const video = document.getElementById('webcam');
        const statusText = document.getElementById('status');
        const PARTICLE_COUNT = 15000;
        let scene, camera, renderer, particles, material;
        let currentShapeIdx = 0;
        let targetShapeIdx = 0;
        let transitionProgress = 1.0;

        // --- 1. Setup Three.js ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const geometry = new THREE.BufferGeometry();
            const basePositions = new Float32Array(PARTICLE_COUNT * 3);
            
            // Define Shape Attributes
            geometry.setAttribute('position', new THREE.BufferAttribute(basePositions, 3));
            geometry.setAttribute('targetPos', new THREE.BufferAttribute(new Float32Array(PARTICLE_COUNT * 3), 3));
            geometry.setAttribute('colorAttr', new THREE.BufferAttribute(new Float32Array(PARTICLE_COUNT * 3), 3));

            // Generate initial shapes
            generateShapeData(geometry);

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uProgress: { value: 1.0 },
                    uColor: { value: new THREE.Color(0x00ffcc) },
                    uExpansion: { value: 1.0 }
                },
                vertexShader: `
                    attribute vec3 targetPos;
                    uniform float uProgress;
                    uniform float uTime;
                    uniform float uExpansion;
                    varying vec3 vColor;
                    void main() {
                        // Morph between current and target
                        vec3 pos = mix(position, targetPos, uProgress);
                        
                        // Apply expansion
                        pos *= uExpansion;

                        // Add subtle noise/float
                        pos.x += sin(uTime + pos.z) * 0.1;
                        pos.y += cos(uTime + pos.x) * 0.1;

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = (10.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                        vColor = vec3(0.5 + pos.x * 0.2, 0.5 + pos.y * 0.2, 0.8);
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    varying vec3 vColor;
                    void main() {
                        float dist = distance(gl_PointCoord, vec2(0.5));
                        if (dist > 0.5) discard;
                        gl_FragColor = vec4(uColor * vColor, 1.0 - (dist * 2.0));
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize);
        }

        // --- 2. Shape Generators ---
        function generateShapeData(geo) {
            const posArr = [];
            
            // Define formulas for 5 templates
            const shapes = [
                () => { // 0: Saturn
                    const i = Math.random() * PARTICLE_COUNT;
                    if (i < PARTICLE_COUNT * 0.4) { // Planet
                        return new THREE.Vector3().setFromSphericalCoords(1.2, Math.random() * Math.PI, Math.random() * Math.PI * 2);
                    } else { // Rings
                        const r = 1.8 + Math.random() * 0.8;
                        const a = Math.random() * Math.PI * 2;
                        return new THREE.Vector3(Math.cos(a) * r, (Math.random() - 0.5) * 0.1, Math.sin(a) * r);
                    }
                },
                () => { // 1: Heart
                    const t = Math.random() * Math.PI * 2;
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    return new THREE.Vector3(x * 0.1, y * 0.1, (Math.random() - 0.5) * 0.5);
                },
                () => { // 2: Flower (Rose Curve)
                    const t = Math.random() * Math.PI * 2;
                    const k = 5;
                    const r = Math.cos(k * t) * 2;
                    return new THREE.Vector3(Math.cos(t) * r, Math.sin(t) * r, (Math.random() - 0.5) * 0.5);
                },
                () => { // 3: Fireworks (Sphere Burst)
                    const r = Math.pow(Math.random(), 0.5) * 2.5;
                    return new THREE.Vector3().setFromSphericalCoords(r, Math.random() * Math.PI, Math.random() * Math.PI * 2);
                }
            ];

            const setAttribute = (attrName, shapeIdx) => {
                const arr = geo.getAttribute(attrName).array;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const p = shapes[shapeIdx]();
                    arr[i * 3] = p.x;
                    arr[i * 3 + 1] = p.y;
                    arr[i * 3 + 2] = p.z;
                }
                geo.getAttribute(attrName).needsUpdate = true;
            };

            // Initial load
            setAttribute('position', 0);
            setAttribute('targetPos', 0);
            window.shapeLogic = setAttribute;
        }

        function triggerMorph(newIdx) {
            if (newIdx === currentShapeIdx) return;
            // Swap current to position attribute
            const targetArr = particles.geometry.getAttribute('targetPos').array;
            const posAttr = particles.geometry.getAttribute('position');
            posAttr.array.set(targetArr);
            posAttr.needsUpdate = true;

            // Load new target
            window.shapeLogic('targetPos', newIdx);
            
            currentShapeIdx = newIdx;
            transitionProgress = 0;
        }

        // --- 3. Hand Gesture Logic ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusText.innerText = "Tracking Active";
                const landmarks = results.multiHandLandmarks[0];

                // 1. Position & Color Control (Middle finger MCP)
                const handX = (landmarks[9].x - 0.5) * 10;
                const handY = -(landmarks[9].y - 0.5) * 10;
                particles.rotation.y = handX * 0.5;
                particles.rotation.x = handY * 0.5;
                material.uniforms.uColor.value.setHSL((landmarks[9].x), 0.8, 0.5);

                // 2. Pinch Control (Expansion) - Distance between Thumb(4) and Index(8)
                const dx = landmarks[4].x - landmarks[8].x;
                const dy = landmarks[4].y - landmarks[8].y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                material.uniforms.uExpansion.value = THREE.MathUtils.lerp(material.uniforms.uExpansion.value, 1 + dist * 5, 0.1);

                // 3. Shape Switch (Finger Count)
                const isRaised = (tip, pip) => landmarks[tip].y < landmarks[pip].y;
                let raisedCount = 0;
                if (isRaised(8, 6)) raisedCount++;  // Index
                if (isRaised(12, 10)) raisedCount++; // Middle
                if (isRaised(16, 14)) raisedCount++; // Ring
                if (isRaised(20, 18)) raisedCount++; // Pinky

                if (raisedCount === 1) triggerMorph(0); // Saturn
                else if (raisedCount === 2) triggerMorph(1); // Heart
                else if (raisedCount === 3) triggerMorph(2); // Flower
                else if (raisedCount >= 4) triggerMorph(3); // Fireworks
            } else {
                statusText.innerText = "Show your hand to the camera";
            }
        });

        const cameraPipe = new Camera(video, {
            onFrame: async () => { await hands.send({ image: video }); },
            width: 640, height: 480
        });
        cameraPipe.start();

        // --- 4. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.uTime.value += 0.01;

            if (transitionProgress < 1.0) {
                transitionProgress += 0.02;
                material.uniforms.uProgress.value = transitionProgress;
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        initThree();
        animate();
    </script>
</body>
</html>
